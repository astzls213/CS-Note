# Part3 运输层

本总结主要面向在校大学生**复习期末考试**，当然也能应付一些**面试**上的问题。这些总结都是作者**有感而发**，因此**不是那种被转发到臭的博文**。因此，各位水友看完觉得有收获可以**点个赞**满足博主那可怜的虚荣心。

总结由于俺龙鸣的学识以及时间有限，难免有错，感谢各路大神不吝赐教。

### 一些概念

- UDP：用户数据报协议，是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- TCP：传输控制协议，是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的。
- Socket：就是一个（IP：Port），Port也即端口号。上一部分我们最后问到两个不同主机的进程是如何通信的，现在我们能够回答，正是由于Port的存在，使得主机从网卡接收到数据后，操作系统解析其传输层首部信息，从而找到对应的进程，并将数据交付给它。

你现在可能会问TCP是如何实现可靠的进程间通信服务？网络本身难道就是可靠的吗？为什么UDP就不可靠了呢？

其实，网络通信本身是**不可靠的**。数据在通过链路媒介传播时，可能受到外力干扰，或者其他什么原因，导致数据丢失，出错等现象。然而，我们的网络使用分组交换技术，导致接收方收到的分组乱序也有可能。

因此，为了解决数据丢失，我们可以引入**等待确认技术**，即发送方等待接收方确认收到分组的信息，再进行下一轮的发送。如果没有收到，则进行重传。

为了解决数据出错，我们可引入**差错校验技术**。接收方可以通过某种算法对当前数据进行运算，然后将运算结果与数据的校验码进行比对，如果不一致，则出错。既然出错，我们就简单的丢弃该分组，让发送方重传，直到没错为止。

为了解决分组乱序，我们可以引入**序号/确认号技术**。即对每个分组进行标号，这个标号对于每个分组都是唯一的。发送方告诉接收方现在发送的是x号分组（序号），并且我想收到你y号的分组（确认号）。接收方如果发送了非y号的分组，发送方会丢弃，直到收到了来自接收方y号分组。

示意图如下：

![TCP示意图](/Users/astzls/Desktop/计算机网络学习总结/TCP示意图.png)

以上只是简单的解释下为什么TCP可以在不可靠的信道模拟可靠，具体的细节请往下看。

### 灵魂拷问环节

1. TCP/UDP是如何计算校验和的？

   计算checksum，我们需要IP伪首部，TCP/UDP首部以及TCP/UDP数据。将这些字节每`2Bytes`构成一组，依次对这些组累加求和，**中间每一步相加时结果溢出时，需要对结果再+1。**最后，对累加求和的结果s进行取反，就得到了checksum。

2. TCP/UDP首部计算校验和为什么还要加上伪首部？伪首部有哪些内容？

   为了保证伪首部的所包含信息正确，这涉及到TCP/IP协议一开始设计的问题。伪首部内容有：

   - 源IP地址（4字节）
   - 目的IP地址（4字节）
   - TCP/UDP总长度（2字节）：即首部+数据长度
   - 协议类型（1字节）：TCP=0x06；UDP=0x11
   - 由0填充的字段（1字节）

3. 建立TCP连接为什么要三次握手？过程是怎样的？

   先讲过程：

   - Client向Server发送报文，该报文TCP首部的SYN为1，并且确定一个初始序号**client_isn**。
   - Server接收到Client的报文，也回应一个报文。报文TCP首部ACK为1，并且确认号为**client_isn+1**。同时，SYN也为1，服务器也确定一个初始序号**server_isn**。
   - Client收到了**SYN ACK报文**，现在他要回一个ACK报文，因此ACK为1，并且序号为**client_isn+1**，确认号为**server_isn+1**。

   至此，Client和Server已经建立了全双工的可靠信道。那么为什么建立连接过程必须要这样呢？

   首先，TCP要保证双向数据传输，即全双工。因此第一次握手，是建立`Client->Server`方向的通信信道（单向的）。第二次握手表明`Client->Server`方向的信道建立完成（ACK），并且请求建立`Server->CLient`方向的通信信道（SYN）。因此，第三次握手代表`Server->CLient`方向的通信信道建立完成，此时连接才是双向的！

4. 断开TCP连接为什么要四次挥手？过程是怎样的？

   先讲过程：

   - Client向Server发送FIN报文
   - Server回应ACK报文。
   - Server向Client发送FIN报文。
   - Client回ServerACK报文。

   至此，Client和Server已经断开了连接。那么为什么断开连接过程必须要这样呢？聪明的你可能根据三次握手的原因已经猜到了。

   还是那句话，TCP是全双工的。因此第一对FIN/ACK，是断开`Client->Server`方向的通信信道。第二对FIN/ACK是断开`Server->CLient`方向的通信信道。因此，需要四次挥手。其实也可以三次挥手，即Server的ACK报文和FIN报文合并在一个报文回应，但这样的前提是Server已经接受完Client的数据。

5. 简述TCP首部**序号**和**确认号**承担的作用。

   首先TCP协议会将来自上层的应用层报文进行分组（如果报文长度大于1460的话），那么为了实现等待-确认，超时重传等协议，有必要用号码标记每个分组。这样，接收方接收到序号x的分组后，可以告诉发送方你接下来可以发送x+len分组（len是本分组字节长度），而这就是设置确认号的秘密。

6. 为什么TCP建立连接时序号不是取0而是取一个随机值？

   一个是出于安全因素，如果序号从一个常量开始，那么序号比较容易被黑客猜到，然后干坏事。

   二是避免旧连接的数据分组与新连接的数据分组撞车。假如一条TCP连接被关闭了，但网络上还存留着他的分组。现在又建立新连接，那么网络上的旧分组到达目的地后可能被当作新分组并缓存。因此选择动态的序号建立新连接可以降低这种事情发生的概率。

7. TCP是如何保证可靠数据传输？

   由于信道是不可靠的（比特错乱，信息丢失），因此可能造成分组丢失，分组乱序，分组数据错误的现象。因此，引入的三部曲对策是：

   - 差错检验
   - 接收方反馈
   - 重传

   因为我们可以运用差错检验发现分组数据错误，接收方此时可以反馈给发送方，发送方就会进行重传，直至接收方正确收到分组为止。接收方为了告诉发送方哪个分组出错，因此将每个分组标上序号。因此TCP协议是由一组协议构成的，我们现在来看看是哪些协议：

   **停止等待协议**：发送方在没有收到接收方的响应报文时，是不会再发送新报文的，这就叫做停止等待协议。

   **自动重传协议**：发送方收到接收方的响应报文如果是NAK（No-Acknowledgement），那么代表接收方没有正确收到数据分组，这是发送方就会进行重传。或者发送方在一段时间内根本就没收到接收方的响应报文，因此发送方自动进行分组的重传，这就叫做自动重传协议。事实上，TCP根本没有定义NAK响应报文，因此，接收方要想NAK，只需重复最后一个ACK报文即可。（比如：之前已经发送了ACK 3，现在想要ACK 4，但是分组4在传输时丢失了，现在又收到了分组5，此时ACK 3即可），这就叫**冗余ACK技术**。

   等等，事情还没有结束。如果分组在网络上“塞车”了，而发送方又重新发了一个分组，这样就造成**分组冗余**，因此接收方要能够检测冗余分组，对于冗余的分组直接丢弃即可。但是，为了构造可靠的信道，损失了我们大量的时间，因为每次发送新分组都要等待接收方的响应。因此引入：

   **流水线级的停止等待协议**：发送方直接发送新的分组，不用等待接收方的响应。但是我们还是要限制发送方发送分组的数量，一是怕接收方缓存溢出（**流量控制**），二是怕整个网络很拥挤（**拥塞控制**）。因此，引入滑动窗口协议。

   **滑动窗口协议**：发送方维护一个窗口，这个窗口是有大小的，也即发送方无需等待确认即可发送分组的数量。那么窗口何时滑动呢？这取决于该窗口的第一个分组。如果发送方接收到窗口的第一个分组的ACK响应报文，那么窗口便向右移一个分组的身位，以此类推。那么如果收不到窗口中的某些分组的ACK响应报文怎么办？于是，又引入回退N步协议和选择重传协议：

   **回退N步协议(Go-Back-N)**：发送方维护一个定时器，定时器对窗口的第一个分组进行计时，若超出等待时长阈值，则重传窗口内的所有分组，这就叫回退N步。因此，对于接收方，要引入**累计确认**的概念。即接收方严格按照序号流进行ACK（如：ACK 0/ACK 1/ACK 2这样），如果是接收方没有收到分组1，却收到了分组2，它也只回应ACK 0。这里有一个交互式的[示意网站](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)。

   **选择重传协议(Selective Repeat)**：正如你所见，回退N步在超时后会重传窗口内的所有分组，这样不就很浪费时间吗？因为接收方可能接收了发送方窗口中的其他分组。因此，选择重传协议**不使用冗余ACK技术**，接收方收到什么就ACK什么，如果之前的分组没收到，接收方会先缓存下来。这里有一个交互式的[示意网站](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)。

8. 简述TCP流量控制方法原理。

   正如前面所说，发送方与接收方都维护一个接收窗口rwnd（receive window）的东西，什么意思呢？我们在三次握手建立TCP连接后，Client和Server各自malloc的一片区域作为分组缓冲区。因此缓冲区是有限的，我们刚刚说发送方会将窗口内的分组一一发送，但是其实不是这样的，在窗口内的分组，也要根据rwnd这个值来决定发不发送窗口内的分组。举个例子：

   接收方每次回应报文时，其TCP首部的接收窗口字段应该填入它缓存剩余容量。发送方查看回应报文，就知道接收方还有多少缓存。那么，发送方发送新分组时必须确保没有超出这个缓存大小，这就避免了接收方缓存溢出的现象。

   因此流量控制就是一个速度匹配服务，发送方发送分组的速度要和接收方接收分组的速度相匹配。

9. 简述TCP拥塞控制方法原理。

   这里作者没时间仔细看，只能说下大概看法。

   - 慢启动：就是发送方发送分组的速率是从一个很小的值慢慢变大，每当接收到正确的ACK报文后，就逐渐加速，直到某个分组响应超时，这时重新从开始的小速率开始发送分组，以此类推。
   - 拥塞避免：当速率到达上次拥塞速率的一半时，就以更缓慢的速率增长，免得很快又到达上次的堵塞速率。还是一样，一旦超时，就回到慢启动模式。

10. 为什么选择重传协议的窗口大小最多是序号空间的一半？

    假设我们的序号字段只有2个比特，即空间为0，1，2，3。同时，设置窗口大小为4。那么对于A传给B一个大文件F时，F会被分成许多个分组，这些分组的序号肯定是重复的，如：

    发送方窗口 ->`[0 1 2 3] 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3`

    接收方窗口 ->`[0 1 2 3] 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3`

    那么，现在假设发送方已发送 0 1 2 3这四个分组，但是接收方的ACK 0回应报文丢失，其余回应正常到达A，`x*`代表收到ACK x。那么：

    发送方窗口 ->`[0 1* 2* 3*] 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3`

    接收方窗口 ->`0 1 2 3 [0 1 2 3] 0 1 2 3 0 1 2 3 0 1 2 3`

    由于发送方没有收到ACK 0，因此重传分组0。问题出现了，接收方误人这个分组0为新的分组0，而不是之前的分组0，这样就造成了文件F的数据损坏。

    至于窗口大小最多为序号空间的一半是因为考虑到像刚刚那样的最坏情况，即每个窗口都是第一个分组的ACK没有到达。而要想接收方不误认，就是避免接收方的窗口包含了下一次循环的分组序号。设窗口大小为N，最坏情况下接收方窗口移动距离也为N。设序号空间为X，只需`N+N<=X`即可。这就是为什么至多为序号空间大小的一半的证明。

### 总结

运输层作用就是为主机中应用程序间构建**逻辑运输信道**，实际上数据入口和出口就是主机的网卡那里，不是直接到达某个应用程序的，因此引入端口，将你的数据在操作系统的帮助下定向到APP的缓存区内。并且，由于通信信道是不可靠的，TCP通过自己的努力让数据不断重传直至到达目的地，实现可靠的信道。这也就是为什么说是抽象的，逻辑的信道。

但是，物理运输信道是怎么工作的呢？即主机与主机间的信道是如何工作的呢？我们需要再往下一层，网络层。